## 多线程与线程安全

### 何时使用多线程

多线程解决什么问题
* 多任务

  * 单线程单任务

  * 单线程多任务 Unity的游戏逻辑

  * 多线程单任务

  * 多线程多任务

* 提升计算性能，计算密集型问题

### 如何安全使用线程

多线程产生的问题

-   线程安全
-   非线程安全

本质是能不能保证多线程访问的数据的一致性，会不会产生访问冲突

C\#的数组遍历不允许增删数组，也体现了保证数据一致性原理。

C\#集合有线程安全类和不可变类。

#### 用于同步的对象

-   lock：最暴力的一种，访问的数据被锁，会一直等待
-   Monitor：lock的底层，比lock灵活点，访问的数据被锁，会去做别的事情
-   Mutex：互斥锁，它指出可锁定对象一次只能由一个线程拥有，并且只有所有者线程才能释放互斥锁上的锁。
-   ReaderWriterLockSlim：读写锁，读取不会互斥，线程不用等待，写会互斥
-   Semaphore：信号量，信号量即线程数，满的话后面的线程需要等待，未满情况下可以共享范文数据
-   Interlocked：原子锁，如果在一个多线程环境下对某个变量进行简单数学运算或者逻辑运算，那么就应该使用原子锁操作。适用于短时间操作线程的互斥场合，并不能替代所有系统互斥锁调用场合。

每种锁代表一种多线程数据访问策略

**锁的范围**

对象》操作（读写）》变量

**同步的错误案例**

每个线程都在等待前一个线程完毕，锁定的对象能带来多大的收益，锁不能滥用

**同步要点**

-   只在必要时加锁
-   加锁的粒度(范围)越小越好
-   取决于解决的问题
